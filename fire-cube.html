<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Fire Cube WebGL</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #info { position: absolute; top: 10px; left: 10px; pointer-events: none; }
    </style>
</head>
<body>
    <div id="info">Fire Cube 3D (WebGL)</div>
    <canvas id="glcanvas"></canvas>

    <!-- Shaders -->
    <script id="vs" type="x-shader/x-vertex">
        attribute vec3 position;
        attribute vec2 uv;
        uniform mat4 uModelView;
        uniform mat4 uProjection;
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = uProjection * uModelView * vec4(position, 1.0);
        }
    </script>

    <script id="fs" type="x-shader/x-fragment">
        precision mediump float;
        varying vec2 vUv;
        uniform sampler2D uTexture;
        void main() {
            gl_FragColor = texture2D(uTexture, vUv);
        }
    </script>

    <script>
        // --- Config ---
        const FIRE_W = 128;
        const FIRE_H = 128;
        
        // --- Globals ---
        let gl, program;
        let fireBuffer = new Uint8Array(FIRE_W * FIRE_H);
        let pixelBuffer = new Uint8Array(FIRE_W * FIRE_H * 4); // RGBA
        let palette = [];
        let texture;
        let rotX = 0, rotY = 0, rotZ = 0;

        // --- Init Palette ---
        function initPalette() {
            for (let i = 0; i < 256; i++) {
                let r = 0, g = 0, b = 0;
                if (i < 64) {
                    r = i * 4;
                } else if (i < 128) {
                    r = 255; g = (i - 64) * 4;
                } else if (i < 192) {
                    r = 255; g = 255; b = (i - 128) * 4;
                } else {
                    r = 255; g = 255; b = 255;
                }
                palette[i] = [r, g, b, 255];
            }
        }

        // --- Fire Logic ---
        function updateFire() {
            // Seed
            let lastRow = (FIRE_H - 1) * FIRE_W;
            for (let x = 0; x < FIRE_W; x++) {
                if (Math.random() < 0.6) {
                    fireBuffer[lastRow + x] = 255 - Math.floor(Math.random() * 50);
                } else {
                    if (fireBuffer[lastRow + x] > 10) fireBuffer[lastRow + x] -= 5;
                }
            }

            // Propagate
            for (let y = 0; y < FIRE_H - 1; y++) {
                for (let x = 0; x < FIRE_W; x++) {
                    let srcIdx = (y + 1) * FIRE_W + x;
                    let val = fireBuffer[srcIdx];
                    if (val === 0) {
                        fireBuffer[y * FIRE_W + x] = 0;
                    } else {
                        let decay = Math.floor(Math.random() * 3);
                        let dstX = x - Math.floor(Math.random() * 3) + 1;
                        if (dstX < 0) dstX = 0;
                        if (dstX >= FIRE_W) dstX = FIRE_W - 1;
                        let dstIdx = y * FIRE_W + dstX;
                        let newVal = val - decay;
                        if (newVal < 0) newVal = 0;
                        fireBuffer[dstIdx] = newVal;
                    }
                }
            }

            // Render to pixels
            for (let i = 0; i < FIRE_W * FIRE_H; i++) {
                let color = palette[fireBuffer[i]];
                let idx = i * 4;
                pixelBuffer[idx] = color[0];
                pixelBuffer[idx+1] = color[1];
                pixelBuffer[idx+2] = color[2];
                pixelBuffer[idx+3] = 255;
            }
        }

        // --- WebGL Boilerplate ---
        function initGL() {
            const canvas = document.getElementById('glcanvas');
            gl = canvas.getContext('webgl');
            if (!gl) return alert("WebGL not supported");

            // Resize
            function resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            window.addEventListener('resize', resize);
            resize();

            // Shader
            const vsSrc = document.getElementById('vs').text;
            const fsSrc = document.getElementById('fs').text;
            const vs = createShader(gl.VERTEX_SHADER, vsSrc);
            const fs = createShader(gl.FRAGMENT_SHADER, fsSrc);
            program = createProgram(vs, fs);
            gl.useProgram(program);

            // Buffers (Cube)
            // V0-V3 (Front), V4-V7 (Back), etc.
            // Simple indexed cube
            const vertices = new Float32Array([
                // Front
                -1, -1,  1,   1, -1,  1,   1,  1,  1,  -1,  1,  1,
                // Back
                -1, -1, -1,  -1,  1, -1,   1,  1, -1,   1, -1, -1,
                // Top
                -1,  1, -1,  -1,  1,  1,   1,  1,  1,   1,  1, -1,
                // Bottom
                -1, -1, -1,   1, -1, -1,   1, -1,  1,  -1, -1,  1,
                // Right
                 1, -1, -1,   1,  1, -1,   1,  1,  1,   1, -1,  1,
                // Left
                -1, -1, -1,  -1, -1,  1,  -1,  1,  1,  -1,  1, -1
            ]);
            
            const uvs = new Float32Array([
                // Front
                0, 1,  1, 1,  1, 0,  0, 0,
                // Back
                1, 1,  1, 0,  0, 0,  0, 1,
                // Top
                0, 1,  0, 0,  1, 0,  1, 1,
                // Bottom
                1, 1,  0, 1,  0, 0,  1, 0,
                // Right
                1, 1,  1, 0,  0, 0,  0, 1,
                // Left
                0, 1,  1, 1,  1, 0,  0, 0
            ]);

            const indices = new Uint16Array([
                0, 1, 2, 0, 2, 3,    // Front
                4, 5, 6, 4, 6, 7,    // Back
                8, 9, 10, 8, 10, 11, // Top
                12, 13, 14, 12, 14, 15, // Bottom
                16, 17, 18, 16, 18, 19, // Right
                20, 21, 22, 20, 22, 23  // Left
            ]);

            const vbo = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            const posLoc = gl.getAttribLocation(program, 'position');
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);

            const uvbo = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, uvbo);
            gl.bufferData(gl.ARRAY_BUFFER, uvs, gl.STATIC_DRAW);
            const uvLoc = gl.getAttribLocation(program, 'uv');
            gl.enableVertexAttribArray(uvLoc);
            gl.vertexAttribPointer(uvLoc, 2, gl.FLOAT, false, 0, 0);

            const ibo = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

            // Texture
            texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            
            gl.enable(gl.DEPTH_TEST);
        }

        function createShader(type, src) {
            const s = gl.createShader(type);
            gl.shaderSource(s, src);
            gl.compileShader(s);
            if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(s));
                return null;
            }
            return s;
        }

        function createProgram(vs, fs) {
            const p = gl.createProgram();
            gl.attachShader(p, vs);
            gl.attachShader(p, fs);
            gl.linkProgram(p);
            return p;
        }

        // --- Math ---
        function mat4Perspective(out, fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            const nf = 1 / (near - far);
            out[0] = f / aspect; out[1] = 0; out[2] = 0; out[3] = 0;
            out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
            out[8] = 0; out[9] = 0; out[10] = (far + near) * nf; out[11] = -1;
            out[12] = 0; out[13] = 0; out[14] = (2 * far * near) * nf; out[15] = 0;
        }

        function mat4Identity(out) {
            for(let i=0; i<16; i++) out[i] = (i%5===0) ? 1 : 0;
        }

        function mat4Translate(out, v) {
            out[12] = out[0]*v[0] + out[4]*v[1] + out[8]*v[2] + out[12];
            out[13] = out[1]*v[0] + out[5]*v[1] + out[9]*v[2] + out[13];
            out[14] = out[2]*v[0] + out[6]*v[1] + out[10]*v[2] + out[14];
            out[15] = out[3]*v[0] + out[7]*v[1] + out[11]*v[2] + out[15];
        }

        function mat4RotateX(out, rad) {
            const s = Math.sin(rad), c = Math.cos(rad);
            const a10 = out[4], a11 = out[5], a12 = out[6], a13 = out[7];
            const a20 = out[8], a21 = out[9], a22 = out[10], a23 = out[11];
            out[4] = a10*c + a20*s; out[5] = a11*c + a21*s; out[6] = a12*c + a22*s; out[7] = a13*c + a23*s;
            out[8] = a20*c - a10*s; out[9] = a21*c - a11*s; out[10] = a22*c - a12*s; out[11] = a23*c - a13*s;
        }
        function mat4RotateY(out, rad) {
            const s = Math.sin(rad), c = Math.cos(rad);
            const a00 = out[0], a01 = out[1], a02 = out[2], a03 = out[3];
            const a20 = out[8], a21 = out[9], a22 = out[10], a23 = out[11];
            out[0] = a00*c - a20*s; out[1] = a01*c - a21*s; out[2] = a02*c - a22*s; out[3] = a03*c - a23*s;
            out[8] = a00*s + a20*c; out[9] = a01*s + a21*c; out[10] = a02*s + a22*c; out[11] = a03*s + a23*c;
        }
        function mat4RotateZ(out, rad) {
            const s = Math.sin(rad), c = Math.cos(rad);
            const a00 = out[0], a01 = out[1], a02 = out[2], a03 = out[3];
            const a10 = out[4], a11 = out[5], a12 = out[6], a13 = out[7];
            out[0] = a00*c + a10*s; out[1] = a01*c + a11*s; out[2] = a02*c + a12*s; out[3] = a03*c + a13*s;
            out[4] = a10*c - a00*s; out[5] = a11*c - a01*s; out[6] = a12*c - a02*s; out[7] = a13*c - a03*s;
        }

        // --- Loop ---
        function loop() {
            requestAnimationFrame(loop);

            // Update Fire
            updateFire();
            
            // Upload Texture
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, FIRE_W, FIRE_H, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixelBuffer);

            // Render
            gl.clearColor(0.1, 0.1, 0.1, 1);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Matrices
            const proj = new Float32Array(16);
            const view = new Float32Array(16);
            mat4Perspective(proj, 45 * Math.PI/180, gl.canvas.width/gl.canvas.height, 0.1, 100);
            
            mat4Identity(view);
            mat4Translate(view, [0, 0, -4]);
            
            rotX += 0.01; rotY += 0.02; rotZ += 0.005;
            mat4RotateX(view, rotX);
            mat4RotateY(view, rotY);
            mat4RotateZ(view, rotZ);

            // Uniforms
            const uProj = gl.getUniformLocation(program, 'uProjection');
            const uView = gl.getUniformLocation(program, 'uModelView');
            gl.uniformMatrix4fv(uProj, false, proj);
            gl.uniformMatrix4fv(uView, false, view);

            // Draw
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
        }

        // --- Start ---
        initPalette();
        initGL();
        loop();

    </script>
</body>
</html>
