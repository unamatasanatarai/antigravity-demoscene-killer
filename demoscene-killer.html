<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Demoscene Killer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            color: #fff;
            font-family: monospace;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
            text-shadow: 1px 1px 0 #000;
        }
    </style>
</head>

<body>
    <div id="info">DEMOSCENE KILLER<br>Fire / Plasma / Smoke / Tunnel</div>
    <canvas id="glcanvas"></canvas>

    <!-- Shaders -->
    <script id="vs" type="x-shader/x-vertex">
        attribute vec3 position;
        attribute vec2 uv;
        uniform mat4 uModelView;
        uniform mat4 uProjection;
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = uProjection * uModelView * vec4(position, 1.0);
        }
    </script>

    <script id="fs" type="x-shader/x-fragment">
        precision mediump float;
        varying vec2 vUv;
        uniform sampler2D uTexture;
        void main() {
            gl_FragColor = texture2D(uTexture, vUv);
        }
    </script>

    <script>
        // --- Config ---
        const TEX_W = 128;
        const TEX_H = 128;

        // --- Globals ---
        let gl, program;
        let rotX = 0, rotY = 0, rotZ = 0;
        let orbitAngle = 0;

        // Buffers for effects
        // 1. Fire
        let firePixels = new Uint8Array(TEX_W * TEX_H);
        let fireRGBA = new Uint8Array(TEX_W * TEX_H * 4);
        let firePalette = [];
        let texFire;

        // 2. Plasma
        let plasmaRGBA = new Uint8Array(TEX_W * TEX_H * 4);
        let plasmaPalette = [];
        let texPlasma;
        let plasmaTime = 0;

        // 3. Smoke
        let smokePixels = new Uint8Array(TEX_W * TEX_H);
        let smokeRGBA = new Uint8Array(TEX_W * TEX_H * 4);
        let smokePalette = [];
        let texSmoke;

        // 4. Tunnel
        let tunnelRGBA = new Uint8Array(TEX_W * TEX_H * 4);
        let texTunnel;
        let tunnelTime = 0;
        // Precomputed tunnel tables
        let tunnelDist = new Uint8Array(TEX_W * TEX_H);
        let tunnelAngle = new Uint8Array(TEX_W * TEX_H);
        let tunnelTex = new Uint8Array(256 * 256 * 4); // The texture looked up by the tunnel

        // --- Initialization ---

        function initPalettes() {
            // Fire Palette (Black -> Red -> Yellow -> White)
            for (let i = 0; i < 256; i++) {
                let r = 0, g = 0, b = 0;
                if (i < 64) { r = i * 4; }
                else if (i < 128) { r = 255; g = (i - 64) * 4; }
                else if (i < 192) { r = 255; g = 255; b = (i - 128) * 4; }
                else { r = 255; g = 255; b = 255; }
                firePalette[i] = [r, g, b, 255];
            }

            // Smoke Palette (Black -> Grey -> White)
            for (let i = 0; i < 256; i++) {
                let c = i; // Linear grey
                // Make it a bit smoky (bluish grey)
                let r = c * 0.8;
                let g = c * 0.8;
                let b = c;
                smokePalette[i] = [Math.min(255, r), Math.min(255, g), Math.min(255, b), 255];
            }

            // Plasma Palette (Rainbow)
            for (let i = 0; i < 256; i++) {
                let r = Math.floor(128 + 127 * Math.sin(i * Math.PI / 32));
                let g = Math.floor(128 + 127 * Math.sin(i * Math.PI / 64 + 2));
                let b = Math.floor(128 + 127 * Math.sin(i * Math.PI / 128 + 4));
                plasmaPalette[i] = [r, g, b, 255];
            }

            // Tunnel Texture Pattern (XOR texture)
            for (let y = 0; y < 256; y++) {
                for (let x = 0; x < 256; x++) {
                    let c = (x ^ y);
                    let idx = (y * 256 + x) * 4;
                    tunnelTex[idx] = c;
                    tunnelTex[idx + 1] = c;
                    tunnelTex[idx + 2] = c;
                    tunnelTex[idx + 3] = 255;
                }
            }

            // Tunnel Tables
            for (let y = 0; y < TEX_H; y++) {
                for (let x = 0; x < TEX_W; x++) {
                    let dx = x - TEX_W / 2;
                    let dy = y - TEX_H / 2;
                    let dist = Math.sqrt(dx * dx + dy * dy);
                    let angle = Math.atan2(dy, dx);

                    tunnelDist[y * TEX_W + x] = Math.min(255, (32 * 256 / (dist + 1))) & 255;
                    tunnelAngle[y * TEX_W + x] = (angle * 128 / Math.PI) & 255;
                }
            }
        }

        // --- Effect Updates ---

        function updateFire() {
            // Seed
            let lastRow = (TEX_H - 1) * TEX_W;
            for (let x = 0; x < TEX_W; x++) {
                if (Math.random() < 0.6) {
                    firePixels[lastRow + x] = 255 - Math.floor(Math.random() * 50);
                } else {
                    if (firePixels[lastRow + x] > 10) firePixels[lastRow + x] -= 5;
                }
            }
            // Propagate
            for (let y = 0; y < TEX_H - 1; y++) {
                for (let x = 0; x < TEX_W; x++) {
                    let srcIdx = (y + 1) * TEX_W + x;
                    let val = firePixels[srcIdx];
                    if (val === 0) {
                        firePixels[y * TEX_W + x] = 0;
                    } else {
                        let decay = Math.floor(Math.random() * 3);
                        let dstX = x - Math.floor(Math.random() * 3) + 1;
                        if (dstX < 0) dstX = 0; if (dstX >= TEX_W) dstX = TEX_W - 1;
                        let newVal = val - decay;
                        if (newVal < 0) newVal = 0;
                        firePixels[y * TEX_W + dstX] = newVal;
                    }
                }
            }
            // Render
            for (let i = 0; i < TEX_W * TEX_H; i++) {
                let c = firePalette[firePixels[i]];
                let idx = i * 4;
                fireRGBA[idx] = c[0]; fireRGBA[idx + 1] = c[1]; fireRGBA[idx + 2] = c[2]; fireRGBA[idx + 3] = 255;
            }
        }

        function updateSmoke() {
            // Similar to fire but different params
            let lastRow = (TEX_H - 1) * TEX_W;
            for (let x = 0; x < TEX_W; x++) {
                if (Math.random() < 0.5) {
                    smokePixels[lastRow + x] = 200 + Math.floor(Math.random() * 55);
                } else {
                    if (smokePixels[lastRow + x] > 5) smokePixels[lastRow + x] -= 2;
                }
            }
            for (let y = 0; y < TEX_H - 1; y++) {
                for (let x = 0; x < TEX_W; x++) {
                    let srcIdx = (y + 1) * TEX_W + x;
                    let val = smokePixels[srcIdx];
                    if (val === 0) {
                        smokePixels[y * TEX_W + x] = 0;
                    } else {
                        // Smoke rises slower and spreads more
                        let decay = 1;
                        let dstX = x - Math.floor(Math.random() * 3) + 1;
                        if (dstX < 0) dstX = 0; if (dstX >= TEX_W) dstX = TEX_W - 1;
                        let newVal = val - decay;
                        if (newVal < 0) newVal = 0;
                        smokePixels[y * TEX_W + dstX] = newVal;
                    }
                }
            }
            for (let i = 0; i < TEX_W * TEX_H; i++) {
                let c = smokePalette[smokePixels[i]];
                let idx = i * 4;
                smokeRGBA[idx] = c[0]; smokeRGBA[idx + 1] = c[1]; smokeRGBA[idx + 2] = c[2]; smokeRGBA[idx + 3] = 255;
            }
        }

        function updatePlasma() {
            plasmaTime += 0.05;
            for (let y = 0; y < TEX_H; y++) {
                for (let x = 0; x < TEX_W; x++) {
                    let v = Math.sin(x * 0.1 + plasmaTime);
                    v += Math.sin(y * 0.1 + plasmaTime);
                    v += Math.sin((x + y) * 0.1 + plasmaTime);
                    v += Math.sin(Math.sqrt(x * x + y * y) * 0.1 + plasmaTime);
                    // Map -4..4 to 0..255
                    let idx = Math.floor((v + 4) * 32) & 255;
                    let c = plasmaPalette[idx];
                    let pIdx = (y * TEX_W + x) * 4;
                    plasmaRGBA[pIdx] = c[0]; plasmaRGBA[pIdx + 1] = c[1]; plasmaRGBA[pIdx + 2] = c[2]; plasmaRGBA[pIdx + 3] = 255;
                }
            }
        }

        function updateTunnel() {
            tunnelTime += 2; // Faster!
            let shiftX = Math.floor(tunnelTime);
            let shiftY = Math.floor(tunnelTime);
            for (let i = 0; i < TEX_W * TEX_H; i++) {
                let u = (tunnelDist[i] + shiftX) & 255;
                let v = (tunnelAngle[i] + shiftY) & 255;
                let texIdx = (v * 256 + u) * 4;
                let idx = i * 4;
                tunnelRGBA[idx] = tunnelTex[texIdx];
                tunnelRGBA[idx + 1] = tunnelTex[texIdx + 1];
                tunnelRGBA[idx + 2] = tunnelTex[texIdx + 2];
                tunnelRGBA[idx + 3] = 255;
            }
        }

        // --- WebGL ---

        function initGL() {
            const canvas = document.getElementById('glcanvas');
            gl = canvas.getContext('webgl');
            if (!gl) return alert("WebGL not supported");

            function resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            window.addEventListener('resize', resize);
            resize();

            // Shader
            const vs = createShader(gl.VERTEX_SHADER, document.getElementById('vs').text);
            const fs = createShader(gl.FRAGMENT_SHADER, document.getElementById('fs').text);
            program = createProgram(vs, fs);
            gl.useProgram(program);

            // Geometry: A single cube
            // We will draw it multiple times with different textures
            // Or we can split the geometry.
            // To support "3 faces fire, 2 plasma, 1 smoke", we need to split the main cube drawing.
            // Let's define the vertices for all faces.

            // Face order: Front, Back, Top, Bottom, Right, Left
            // Fire: Front, Back, Top (0, 1, 2)
            // Plasma: Bottom, Right (3, 4)
            // Smoke: Left (5)

            const vertices = new Float32Array([
                // Front
                -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1,
                // Back
                -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1,
                // Top
                -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1,
                // Bottom
                -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1,
                // Right
                1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1,
                // Left
                -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1
            ]);

            const uvs = new Float32Array([
                // Front
                0, 1, 1, 1, 1, 0, 0, 0,
                // Back
                1, 1, 1, 0, 0, 0, 0, 1,
                // Top
                0, 1, 0, 0, 1, 0, 1, 1,
                // Bottom
                1, 1, 0, 1, 0, 0, 1, 0,
                // Right
                1, 1, 1, 0, 0, 0, 0, 1,
                // Left
                0, 1, 1, 1, 1, 0, 0, 0
            ]);

            const indices = new Uint16Array([
                0, 1, 2, 0, 2, 3,    // Front
                4, 5, 6, 4, 6, 7,    // Back
                8, 9, 10, 8, 10, 11, // Top
                12, 13, 14, 12, 14, 15, // Bottom
                16, 17, 18, 16, 18, 19, // Right
                20, 21, 22, 20, 22, 23  // Left
            ]);

            const vbo = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            const posLoc = gl.getAttribLocation(program, 'position');
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);

            const uvbo = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, uvbo);
            gl.bufferData(gl.ARRAY_BUFFER, uvs, gl.STATIC_DRAW);
            const uvLoc = gl.getAttribLocation(program, 'uv');
            gl.enableVertexAttribArray(uvLoc);
            gl.vertexAttribPointer(uvLoc, 2, gl.FLOAT, false, 0, 0);

            const ibo = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

            // Textures
            texFire = createTexture();
            texPlasma = createTexture();
            texSmoke = createTexture();
            texTunnel = createTexture();

            gl.enable(gl.DEPTH_TEST);
        }

        function createTexture() {
            const t = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, t);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            return t;
        }

        function createShader(type, src) {
            const s = gl.createShader(type);
            gl.shaderSource(s, src);
            gl.compileShader(s);
            if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(s)); return null;
            }
            return s;
        }

        function createProgram(vs, fs) {
            const p = gl.createProgram();
            gl.attachShader(p, vs);
            gl.attachShader(p, fs);
            gl.linkProgram(p);
            return p;
        }

        // --- Math Helpers ---
        function mat4Perspective(out, fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            const nf = 1 / (near - far);
            out[0] = f / aspect; out[1] = 0; out[2] = 0; out[3] = 0;
            out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
            out[8] = 0; out[9] = 0; out[10] = (far + near) * nf; out[11] = -1;
            out[12] = 0; out[13] = 0; out[14] = (2 * far * near) * nf; out[15] = 0;
        }
        function mat4Identity(out) { for (let i = 0; i < 16; i++) out[i] = (i % 5 === 0) ? 1 : 0; }
        function mat4Translate(out, v) {
            out[12] = out[0] * v[0] + out[4] * v[1] + out[8] * v[2] + out[12];
            out[13] = out[1] * v[0] + out[5] * v[1] + out[9] * v[2] + out[13];
            out[14] = out[2] * v[0] + out[6] * v[1] + out[10] * v[2] + out[14];
            out[15] = out[3] * v[0] + out[7] * v[1] + out[11] * v[2] + out[15];
        }
        function mat4Scale(out, v) {
            out[0] *= v[0]; out[1] *= v[0]; out[2] *= v[0];
            out[4] *= v[1]; out[5] *= v[1]; out[6] *= v[1];
            out[8] *= v[2]; out[9] *= v[2]; out[10] *= v[2];
        }
        function mat4RotateX(out, rad) {
            const s = Math.sin(rad), c = Math.cos(rad);
            const a10 = out[4], a11 = out[5], a12 = out[6], a13 = out[7];
            const a20 = out[8], a21 = out[9], a22 = out[10], a23 = out[11];
            out[4] = a10 * c + a20 * s; out[5] = a11 * c + a21 * s; out[6] = a12 * c + a22 * s; out[7] = a13 * c + a23 * s;
            out[8] = a20 * c - a10 * s; out[9] = a21 * c - a11 * s; out[10] = a22 * c - a12 * s; out[11] = a23 * c - a13 * s;
        }
        function mat4RotateY(out, rad) {
            const s = Math.sin(rad), c = Math.cos(rad);
            const a00 = out[0], a01 = out[1], a02 = out[2], a03 = out[3];
            const a20 = out[8], a21 = out[9], a22 = out[10], a23 = out[11];
            out[0] = a00 * c - a20 * s; out[1] = a01 * c - a21 * s; out[2] = a02 * c - a22 * s; out[3] = a03 * c - a23 * s;
            out[8] = a00 * s + a20 * c; out[9] = a01 * s + a21 * c; out[10] = a02 * s + a22 * c; out[11] = a03 * s + a23 * c;
        }
        function mat4RotateZ(out, rad) {
            const s = Math.sin(rad), c = Math.cos(rad);
            const a00 = out[0], a01 = out[1], a02 = out[2], a03 = out[3];
            const a10 = out[4], a11 = out[5], a12 = out[6], a13 = out[7];
            out[0] = a00 * c + a10 * s; out[1] = a01 * c + a11 * s; out[2] = a02 * c + a12 * s; out[3] = a03 * c + a13 * s;
            out[4] = a10 * c - a00 * s; out[5] = a11 * c - a01 * s; out[6] = a12 * c - a02 * s; out[7] = a13 * c - a03 * s;
        }
        function mat4Copy(out, a) { for (let i = 0; i < 16; i++) out[i] = a[i]; }

        // --- Loop ---
        function loop() {
            requestAnimationFrame(loop);

            // Update Effects
            updateFire();
            updatePlasma();
            updateSmoke();
            updateTunnel();

            // Upload Textures
            gl.bindTexture(gl.TEXTURE_2D, texFire);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, TEX_W, TEX_H, 0, gl.RGBA, gl.UNSIGNED_BYTE, fireRGBA);

            gl.bindTexture(gl.TEXTURE_2D, texPlasma);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, TEX_W, TEX_H, 0, gl.RGBA, gl.UNSIGNED_BYTE, plasmaRGBA);

            gl.bindTexture(gl.TEXTURE_2D, texSmoke);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, TEX_W, TEX_H, 0, gl.RGBA, gl.UNSIGNED_BYTE, smokeRGBA);

            gl.bindTexture(gl.TEXTURE_2D, texTunnel);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, TEX_W, TEX_H, 0, gl.RGBA, gl.UNSIGNED_BYTE, tunnelRGBA);

            // --- Render Background Tunnel ---
            // Use a full-screen quad. We can reuse the cube vertices? No, need a quad.
            // Let's generate a quad on the fly or use a specific buffer.
            // Actually, we can just draw a big quad at z=-10 scaled up.

            gl.disable(gl.DEPTH_TEST); // Background should be behind everything

            const bgModel = new Float32Array(16);
            mat4Identity(bgModel);
            // Scale up to cover screen. At z=-10, with FOV 45, height is ~8.28.
            // Let's just put it at z=0 with identity projection? 
            // Easier: Use a separate shader or just modify projection for BG.
            // Let's stick to the 3D scene but put a huge quad far away.
            mat4Translate(bgModel, [0, 0, -20]);
            mat4Scale(bgModel, [20, 20, 1]); // Big enough

            gl.bindTexture(gl.TEXTURE_2D, texTunnel);
            const uView = gl.getUniformLocation(program, 'uModelView'); // uView needs to be declared here
            gl.uniformMatrix4fv(uView, false, bgModel);

            // We need a quad. The cube has faces. Face 0 (Front) is a quad.
            // Indices 0..5.
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);

            gl.clear(gl.DEPTH_BUFFER_BIT); // Clear depth so cubes draw on top
            gl.enable(gl.DEPTH_TEST);

            // --- Render Cubes ---
            gl.clearColor(0.1, 0.1, 0.1, 1);
            gl.clear(gl.COLOR_BUFFER_BIT); // Clear color buffer after background draw

            const proj = new Float32Array(16);
            mat4Perspective(proj, 45 * Math.PI / 180, gl.canvas.width / gl.canvas.height, 0.1, 100);

            const uProj = gl.getUniformLocation(program, 'uProjection');
            gl.uniformMatrix4fv(uProj, false, proj);

            // Main Cube Rotation
            rotX += 0.01; rotY += 0.015; rotZ += 0.005;
            const model = new Float32Array(16);
            mat4Identity(model);
            mat4Translate(model, [0, 0, -5]);
            mat4RotateX(model, rotX);
            mat4RotateY(model, rotY);
            mat4RotateZ(model, rotZ);

            // Draw Main Cube Faces
            // 1. Fire (Faces 0, 1, 2 -> Indices 0..17)
            gl.bindTexture(gl.TEXTURE_2D, texFire);
            gl.uniformMatrix4fv(uView, false, model);
            gl.drawElements(gl.TRIANGLES, 18, gl.UNSIGNED_SHORT, 0);

            // 2. Plasma (Faces 3, 4 -> Indices 18..29)
            gl.bindTexture(gl.TEXTURE_2D, texPlasma);
            gl.drawElements(gl.TRIANGLES, 12, gl.UNSIGNED_SHORT, 18 * 2); // Offset in bytes

            // 3. Smoke (Face 5 -> Indices 30..35)
            gl.bindTexture(gl.TEXTURE_2D, texSmoke);
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 30 * 2);

            // Orbiting Cubes
            orbitAngle += 0.02;
            for (let i = 0; i < 4; i++) {
                const orbitModel = new Float32Array(16);
                mat4Copy(orbitModel, model); // Start from main cube rotation? No, orbit around center

                // Reset to center
                mat4Identity(orbitModel);
                mat4Translate(orbitModel, [0, 0, -5]);

                // Orbit
                let angle = orbitAngle + (i * Math.PI / 2);
                let radius = 2.5;
                mat4Translate(orbitModel, [Math.cos(angle) * radius, Math.sin(angle) * radius, Math.sin(angle * 2) * 1.0]);

                // Rotate local
                mat4RotateX(orbitModel, rotX * 2);
                mat4RotateY(orbitModel, rotY * 2);

                // Scale down
                mat4Scale(orbitModel, [0.3, 0.3, 0.3]);

                gl.bindTexture(gl.TEXTURE_2D, texTunnel);
                gl.uniformMatrix4fv(uView, false, orbitModel);
            }
        }

        // --- Start ---
        initPalettes();
        initGL();
        loop();

    </script>
</body>

</html>